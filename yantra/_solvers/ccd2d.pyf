!    -*- f90 -*-
! Note: the context of this file is case sensitive.

python module ccd2d ! in 
    interface  ! in :ccd2d
        subroutine edfij(feq,t,u) ! in :ccd2d:ccd2d.f90
            real(kind=8) dimension(5),intent(inout) :: feq
            real(kind=8) intent(in) :: t
            real(kind=8) dimension(2),intent(in) :: u
        end subroutine edfij
        subroutine tij(t,f) ! in :ccd2d:ccd2d.f90
            real(kind=8) intent(out) :: t
            real(kind=8) dimension(5),intent(in) :: f
        end subroutine tij
        subroutine gradtij(gradt,f,u,tau) ! in :ccd2d:ccd2d.f90
            real(kind=8) dimension(2),intent(out) :: gradt
            real(kind=8) dimension(5),intent(in) :: f
            real(kind=8) dimension(2),intent(in) :: u
            real(kind=8) intent(in) :: tau
        end subroutine gradtij
        subroutine totalfluxij(flux,f,u,rho,cp,kappa,tau) ! in :ccd2d:ccd2d.f90
            real(kind=8) dimension(2),intent(out) :: flux
            real(kind=8) dimension(5),intent(in) :: f
            real(kind=8) dimension(2),intent(in) :: u
            real(kind=8) intent(in) :: rho
            real(kind=8) intent(in) :: cp
            real(kind=8) intent(in) :: kappa
            real(kind=8) intent(in) :: tau
        end subroutine totalfluxij
        subroutine total_flux(flux,f,u,rho,cp,kappa,tau,nodetype,ly,lx) ! in :ccd2d:ccd2d.f90
            real(kind=8) dimension(2,ly,lx),intent(out),depend(ly,lx) :: flux
            real(kind=8) dimension(ly,lx,5),intent(in) :: f
            real(kind=8) dimension(2,ly,lx),intent(in),depend(ly,lx) :: u
            real(kind=8) dimension(ly,lx),intent(in),depend(ly,lx) :: rho
            real(kind=8) dimension(ly,lx),intent(in),depend(ly,lx) :: cp
            real(kind=8) dimension(ly,lx),intent(in),depend(ly,lx) :: kappa
            real(kind=8) dimension(ly,lx),intent(in),depend(ly,lx) :: tau
            real(kind=8) dimension(ly,lx),intent(in),depend(ly,lx) :: nodetype
            integer, optional,intent(in),check(shape(f,0)==ly),depend(f) :: ly=shape(f,0)
            integer, optional,intent(in),check(shape(f,1)==lx),depend(f) :: lx=shape(f,1)
        end subroutine total_flux
        subroutine grad_t(gradt,f,u,tau,nodetype,ly,lx) ! in :ccd2d:ccd2d.f90
            real(kind=8) dimension(2,ly,lx),intent(out),depend(ly,lx) :: gradt
            real(kind=8) dimension(ly,lx,5),intent(in) :: f
            real(kind=8) dimension(2,ly,lx),intent(in),depend(ly,lx) :: u
            real(kind=8) dimension(ly,lx),intent(in),depend(ly,lx) :: tau
            real(kind=8) dimension(ly,lx),intent(in),depend(ly,lx) :: nodetype
            integer, optional,intent(in),check(shape(f,0)==ly),depend(f) :: ly=shape(f,0)
            integer, optional,intent(in),check(shape(f,1)==lx),depend(f) :: lx=shape(f,1)
        end subroutine grad_t
        subroutine compute_macro_var(f,t,nodetype,ly,lx) ! in :ccd2d:ccd2d.f90
            real(kind=8) dimension(ly,lx,5),intent(in) :: f
            real(kind=8) dimension(ly,lx),intent(inout),depend(ly,lx) :: t
            real(kind=8) dimension(ly,lx),intent(in),depend(ly,lx) :: nodetype
            integer, optional,intent(in),check(shape(f,0)==ly),depend(f) :: ly=shape(f,0)
            integer, optional,intent(in),check(shape(f,1)==lx),depend(f) :: lx=shape(f,1)
        end subroutine compute_macro_var
        subroutine compute_edf(f,t,u,nodetype,ly,lx) ! in :ccd2d:ccd2d.f90
            real(kind=8) dimension(ly,lx,5),intent(out),depend(ly,lx) :: f
            real(kind=8) dimension(ly,lx),intent(in) :: t
            real(kind=8) dimension(2,ly,lx),intent(in),depend(ly,lx) :: u
            real(kind=8) dimension(ly,lx),intent(in),depend(ly,lx) :: nodetype
            integer, optional,intent(in),check(shape(t,0)==ly),depend(t) :: ly=shape(t,0)
            integer, optional,intent(in),check(shape(t,1)==lx),depend(t) :: lx=shape(t,1)
        end subroutine compute_edf
        subroutine collide_srt(f,t,u,nodetype,tau,ss,kappa,rho,cp,periodicity,ly,lx) ! in :ccd2d:ccd2d.f90
            real(kind=8) dimension(ly,lx,5),intent(inout) :: f
            real(kind=8) dimension(ly,lx),intent(in),depend(ly,lx) :: t
            real(kind=8) dimension(2,ly,lx),intent(in),depend(ly,lx) :: u
            real(kind=8) dimension(ly,lx),intent(in),depend(ly,lx) :: nodetype
            real(kind=8) dimension(ly,lx),intent(in),depend(ly,lx) :: tau
            real(kind=8) dimension(ly,lx),intent(in),depend(ly,lx) :: ss
            real(kind=8) dimension(ly,lx),intent(in),depend(ly,lx) :: kappa
            real(kind=8) dimension(ly,lx),intent(in),depend(ly,lx) :: rho
            real(kind=8) dimension(ly,lx),intent(in),depend(ly,lx) :: cp
            integer dimension(2),intent(in) :: periodicity
            integer, optional,intent(in),check(shape(f,0)==ly),depend(f) :: ly=shape(f,0)
            integer, optional,intent(in),check(shape(f,1)==lx),depend(f) :: lx=shape(f,1)
        end subroutine collide_srt
        subroutine collide_trt(f,t,u,nodetype,tau_a,magicpara,ss,kappa,rho,cp,periodicity,ly,lx) ! in :ccd2d:ccd2d.f90
            real(kind=8) dimension(ly,lx,5),intent(inout) :: f
            real(kind=8) dimension(ly,lx),intent(in),depend(ly,lx) :: t
            real(kind=8) dimension(2,ly,lx),intent(in),depend(ly,lx) :: u
            real(kind=8) dimension(ly,lx),intent(in),depend(ly,lx) :: nodetype
            real(kind=8) dimension(ly,lx),intent(in),depend(ly,lx) :: tau_a
            real(kind=8) intent(in) :: magicpara
            real(kind=8) dimension(ly,lx),intent(in),depend(ly,lx) :: ss
            real(kind=8) dimension(ly,lx),intent(in),depend(ly,lx) :: kappa
            real(kind=8) dimension(ly,lx),intent(in),depend(ly,lx) :: rho
            real(kind=8) dimension(ly,lx),intent(in),depend(ly,lx) :: cp
            integer dimension(2),intent(in) :: periodicity
            integer, optional,intent(in),check(shape(f,0)==ly),depend(f) :: ly=shape(f,0)
            integer, optional,intent(in),check(shape(f,1)==lx),depend(f) :: lx=shape(f,1)
        end subroutine collide_trt
        subroutine stream_and_bounce(f,nodetype,periodicity,ly,lx) ! in :ccd2d:ccd2d.f90
            real(kind=8) dimension(ly,lx,5),intent(inout) :: f
            real(kind=8) dimension(ly,lx),intent(in),depend(ly,lx) :: nodetype
            integer dimension(2),intent(in) :: periodicity
            integer, optional,intent(in),check(shape(f,0)==ly),depend(f) :: ly=shape(f,0)
            integer, optional,intent(in),check(shape(f,1)==lx),depend(f) :: lx=shape(f,1)
        end subroutine stream_and_bounce
        subroutine boundary_conditions(f,u,nodetype,tau,kappa,rho,cp,interp,topbc,topval,bottombc,bottomval,leftbc,leftval,rightbc,rightval,ly,lx) ! in :ccd2d:ccd2d.f90
            real(kind=8) dimension(ly,lx,5),intent(inout) :: f
            real(kind=8) dimension(2,ly,lx),intent(in),depend(ly,lx) :: u
            real(kind=8) dimension(ly,lx),intent(in),depend(ly,lx) :: nodetype
            real(kind=8) dimension(ly,lx),intent(in),depend(ly,lx) :: tau
            real(kind=8) dimension(ly,lx),intent(in),depend(ly,lx) :: kappa
            real(kind=8) dimension(ly,lx),intent(in),depend(ly,lx) :: rho
            real(kind=8) dimension(ly,lx),intent(in),depend(ly,lx) :: cp
            integer intent(in) :: interp
            character*(*) intent(in) :: topbc
            real(kind=8) dimension(lx),intent(in),depend(lx) :: topval
            character*(*) intent(in) :: bottombc
            real(kind=8) dimension(lx),intent(in),depend(lx) :: bottomval
            character*(*) intent(in) :: leftbc
            real(kind=8) dimension(ly),intent(in),depend(ly) :: leftval
            character*(*) intent(in) :: rightbc
            real(kind=8) dimension(ly),intent(in),depend(ly) :: rightval
            integer, optional,intent(in),check(shape(f,0)==ly),depend(f) :: ly=shape(f,0)
            integer, optional,intent(in),check(shape(f,1)==lx),depend(f) :: lx=shape(f,1)
        end subroutine boundary_conditions
    end interface 
end python module ccd2d

! This file was auto-generated with f2py (version:2).
! See http://cens.ioc.ee/projects/f2py2e/
